# -*- snakemake -*-
import os
import re
from collections import namedtuple

try:
    from snakemakelib.config import SNAKEMAKELIB_PATH, SNAKEMAKELIB_RULES_PATH
    from snakemakelib.bio.ngs.regexp import RunRegexp, SampleRegexp
    from snakemakelib.bio.ngs.db import ref, index, annotation, chromosomes
    from snakemakelib.utils import utc_time
    from snakemakelib.stat import is_compressed
except:
    import datetime
    utc_time = lambda: datetime.datetime.isoformat(datetime.datetime.utcnow())
    index = lambda ref, application, build=None, index="", index_name="": index
    annotation = lambda db_config, annotation='ref-transcripts.gtf', ignore_extra_ref=False, fmt="gtf": annotation
    ref = lambda ref, db_config: ref
    chromosomes = lambda ref: []
    RunRegexp = re.compile
    SampleRegexp = re.compile
    is_compressed = lambda: not re.search("(.gz$|.zip$|.bzip2$)", f) is None

include: "../../settings.rules"

# Add configuration variable to snakemake global config object
config['samples'] = config.get("samples", [])
config['regions'] = config.get("regions", []) 
config['runs'] = config.get("runs", [])

# Predefined sample organization configurations
#
# The dictionaries below give examples of some commonly used sample
# configurations. A specific sample organization is activated by
# setting the 'sample_organization' key below. Configurations must
# include:
#
# raw_run_re: RunRegexp for raw data, as delivered from sequencing facility or the like
# run_id_re: RunRegexp for run naming, which may or may not be different from 'raw_run_re'
# sample_re: SampleRegexp for sample naming
#
sample_org = namedtuple('sample_organization', 'raw_run_re run_id_re sample_re')
sample_organization = {
    # All data in sample directory
    'sample' : { 'sampleorg' : sample_org(RunRegexp(os.path.join("(?P<SM>[a-zA-Z0-9]+)", "(?P=SM)")),
                                          RunRegexp(os.path.join("(?P<SM>[a-zA-Z0-9]+)", "(?P=SM)")),
                                          SampleRegexp(os.path.join("(?P<SM>[a-zA-Z0-9]+)", "(?P=SM)"))),
                },
    # Data in sample directory divided in subdirectory for each run, SRA-like
    'sample_run_sra' : {
        'sampleorg' : sample_org(RunRegexp(os.path.join("(?P<SM>[a-zA-Z0-9]+)", "(?P<PU>[a-zA-Z0-9]+)", "(?P=PU)")),
                                 RunRegexp(os.path.join("(?P<SM>[a-zA-Z0-9]+)", "(?P<PU>[a-zA-Z0-9]+)", "(?P=PU)")),
                                 SampleRegexp(os.path.join("(?P<SM>[a-zA-Z0-9]+)", "(?P=SM)"))),
        },
    # Data in sample directory divided in subdirectory for each run, illumina-like
    'sample_run_illumina' : {
        'sampleorg' : sample_org(RunRegexp(os.path.join("(?P<SM>P[0-9]+_[0-9]+)", "(?P<DT>[0-9]+)_(?P<PU>[A-Z0-9]+XX)", "(?:[0-9])_(?P=DT)_(?P=PU)_(?P=SM)")),
                                 RunRegexp(os.path.join("(?P<SM>P[0-9]+_[0-9]+)", "(?P<DT>[0-9]+)_(?P<PU>[A-Z0-9]+XX)", "(?:[0-9])_(?P=DT)_(?P=PU)_(?P=SM)")),
                                 SampleRegexp(os.path.join("(?P<SM>P[0-9]+_[0-9]+)", "(?P=SM)"))),
        },
    # Illumina sequence data as delivered by SciLife
    'Illumina@SciLife' : {
        'sampleorg' : sample_org(RunRegexp(os.path.join("(?P<SM>P[0-9]+_[0-9]+)", "(?P<DT>[0-9]+)_(?P<PU1>[A-Z0-9]+XX)", "(?P<PU2>[0-9])_(?P=DT)_(?P=PU1)_(?P=SM)")),
                                 RunRegexp(os.path.join("(?P<SM>P[0-9]+_[0-9]+)", "(?P<DT>[0-9]+)_(?P<PU1>[A-Z0-9]+XX)", "(?P<PU2>[0-9])_(?P=DT)_(?P=PU1)_(?P=SM)")),
                                 SampleRegexp(os.path.join("(?P<SM>P[0-9]+_[0-9]+)", "(?P=SM)"))),
        },
    'PacBio' : {
    },
    'SOLiD' : {
    },
}

config_default = { 
    'bio.ngs.settings' : {
        'aligner' : "bwa",
        'center' : "",
        'fastq_suffix' : ".fastq.gz",
        'sample_organization' : "sample",
        'read1_label' : "_1",
        'read2_label' : "_2",
        'read1_suffix' : ".fastq.gz",
        'read2_suffix' : ".fastq.gz",
        'read_length' : 100,
        'regions' : config["regions"],
        'runs' : config["runs"],
        'samples' : config["samples"],
        'sampleinfo' : "", # generic; samplesheet could be Illuminas csv samplesheet; treat elsewhere?
        'sample_column_map' : {}, # map regexp group names to column names in sampleinfo
        'threads' : 8,
        'annotation' : {
            'annot_label' : "",
            'transcript_annot_gtf' : "ref-transcripts.gtf",
        },
        'db' : {
            'dbsnp' : "",
            'ref' : "",
            'extra_ref' : [],
            'build' : '',
            'build_config' : None,
        },
        'java' : {
            'java_mem' : "8g",
            'java_tmpdir' : "/tmp",
        },
        'sequence_capture' : {
            'bait_regions' : "",
            'target_regions' : "",
        },
        'rnaseq' : {
            'quantification' : ['rsem'],
        },
    },
}

update_config(config_default, config)
config = config_default

config['bio.ngs.settings']['db']['ref'] = ref(config['bio.ngs.settings']['db']['ref'], 
                                              config['bio.ngs.settings']['db'])
config_default2 = {
    'bio.ngs.settings' : {
        'filter_suffix' :  config['bio.ngs.settings']['read1_label'] + config['bio.ngs.settings']['fastq_suffix'],
    },
}

update_config(config_default2, config)
config = config_default2

config_default3 = {
    'bio.ngs.settings' : sample_organization[config['bio.ngs.settings']['sample_organization']]}

update_config(config_default3, config)
config = config_default3
